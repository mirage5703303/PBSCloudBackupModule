//! Types for cloud backup API
use anyhow::{bail, Error};
use serde::{Deserialize, Serialize};

use proxmox_schema::{api, IntegerSchema, Schema, StringSchema, Updater};

pub const CLOUD_BUCKET_NAME_SCHEMA: Schema = StringSchema::new("Cloud Bucket Identifier.")
    .min_length(3)
    .max_length(64)
    .schema();

pub const CLOUD_STORAGE_PATH_SCHEMA: Schema = StringSchema::new("The path to the cloud storage bucket or container.").schema();

pub const BACKUP_OBJECT_NAME_SCHEMA: Schema = StringSchema::new("Name of the backup object.")
    .min_length(3)
    .max_length(128)
    .schema();

#[api(
    properties: {
        name: {
            schema: CLOUD_BUCKET_NAME_SCHEMA,
        }
    }
)]
#[derive(Serialize, Deserialize)]
/// Simulate cloud buckets (only for test and debug)
#[serde(rename_all = "kebab-case")]
pub struct VirtualCloudBucket {
    pub name: String,
    /// Path to directory simulating the bucket
    pub path: String,
    /// Maximum size for the bucket
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_size: Option<usize>,
}

#[api(
    properties: {
        name: {
            schema: CLOUD_BUCKET_NAME_SCHEMA,
        },
        path: {
            schema: CLOUD_STORAGE_PATH_SCHEMA,
        },
    }
)]
#[derive(Serialize, Deserialize, Updater, Clone)]
#[serde(rename_all = "kebab-case")]
/// Cloud storage configuration
pub struct CloudStorageConfig {
    #[updater(skip)]
    pub name: String,
    pub path: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    /// Region of the storage bucket
    pub region: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    /// Storage class (e.g., STANDARD, INFREQUENT_ACCESS, etc.)
    pub storage_class: Option<String>,
}

#[api(
    properties: {
        config: {
            type: CloudStorageConfig,
        },
        info: {
            type: OptionalCloudMetadata,
        },
    }
)]
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
/// Cloud bucket list entry
pub struct CloudBucketListEntry {
    #[serde(flatten)]
    pub config: CloudStorageConfig,
    #[serde(flatten)]
    pub info: OptionalCloudMetadata,
    /// The state of the bucket if locked or unavailable
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
}

#[api()]
#[derive(Serialize, Deserialize)]
/// Metadata for cloud resources
pub struct OptionalCloudMetadata {
    /// Provider (e.g., AWS, Azure, GCP)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provider: Option<String>,
    /// Resource ID (autogenerated by the provider)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_id: Option<String>,
    /// Creation timestamp
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<i64>,
}

#[api()]
#[derive(Serialize, Deserialize, Copy, Clone, Debug, PartialOrd, PartialEq)]
pub enum CloudStorageClass {
    /// Standard
    Standard,
    /// Infrequent Access
    InfrequentAccess,
    /// Archive
    Archive,
}

impl TryFrom<&str> for CloudStorageClass {
    type Error = Error;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value.to_lowercase().as_str() {
            "standard" => Ok(CloudStorageClass::Standard),
            "infrequent_access" => Ok(CloudStorageClass::InfrequentAccess),
            "archive" => Ok(CloudStorageClass::Archive),
            _ => bail!("unknown cloud storage class: {}", value),
        }
    }
}

#[api(
    properties: {
        storage_class: {
            type: CloudStorageClass,
            optional: true,
        },
    },
)]
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "kebab-case")]
/// Cloud object metadata
pub struct CloudObjectMetadata {
    /// Name of the object
    pub object_name: String,
    /// Size of the object in bytes
    pub size: u64,
    /// Storage class of the object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub storage_class: Option<CloudStorageClass>,
    /// Last modified timestamp
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<i64>,
    /// Encryption status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<bool>,
}
